<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>KTP Weekly Matches Panel</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --card: #1f2937;
      --muted: #9CA3AF;
      --ok: #22c55e;
      --err: #ef4444;
      --warn: #f59e0b;
      --txt: #e5e7eb;
      --accent: #60a5fa;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--txt);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }

    h1 {
      margin: 16px 0 12px;
      font-size: 22px;
    }

    h2 {
      margin: 14px 0 8px;
      font-size: 16px;
      color: var(--muted);
      font-weight: 600;
    }

    .wrap {
      max-width: 1050px;
      margin: 0 auto;
      padding: 16px 20px 120px;
      padding-right: 340px; /* Make room for debug dock */
    }

    @media (min-width: 1800px) {
      .wrap {
        margin-left: calc(50% - 685px); /* Center accounting for debug dock */
        margin-right: auto;
      }
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
    }

    .card {
      background: var(--card);
      border: 1px solid #374151;
      border-radius: 10px;
      padding: 12px;
      box-shadow: 0 1px 0 rgb(255 255 255 / 0.02) inset, 0 8px 24px rgb(0 0 0 / 0.25);
    }

    .card h2 {
      margin-top: 2px;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin: 6px 0;
    }

    .row label {
      font-size: 12px;
      color: var(--muted);
      margin-right: 6px;
    }

    .row input[type="text"],
    .row input[type="password"] {
      background: #0b1220;
      color: var(--txt);
      border: 1px solid #334155;
      padding: 8px 10px;
      border-radius: 8px;
      min-width: 220px;
      outline: none;
    }

    .row input[type="checkbox"] {
      transform: translateY(1px);
    }

    .btn {
      background: #0b1220;
      color: var(--txt);
      border: 1px solid #3b82f6;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    .btn:hover {
      background: #0b1529;
    }

    .btn.warn {
      border-color: var(--warn);
      color: #fff;
    }

    .btn.danger {
      border-color: var(--err);
      color: #fff;
    }

    .btn.ok {
      border-color: var(--ok);
    }

    .pill {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: .3px;
      border: 1px solid #374151;
      background: #0b1220;
      color: var(--muted);
    }

    .status {
      margin-left: 8px;
    }

    .status.ok {
      color: var(--ok);
      border-color: var(--ok);
    }

    .status.err {
      color: var(--err);
      border-color: var(--err);
    }

    .status.busy {
      color: var(--warn);
      border-color: var(--warn);
    }

    /* Debug dock (fixed, top-right) */
    .debug-dock {
      position: fixed;
      right: 16px;
      top: 16px;
      bottom: 16px;
      width: 320px;
      background: var(--panel);
      border: 1px solid #374151;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      z-index: 9999;
      box-shadow: 0 8px 28px rgba(0, 0, 0, .35);
    }

    .debug-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      border-bottom: 1px solid #30363d;
      background: #0b1220;
    }

    .debug-head b {
      font-size: 12px;
      color: var(--muted);
    }

    .debug-actions {
      display: flex;
      gap: 6px;
    }

    .debug-actions .btn {
      padding: 6px 8px;
      font-size: 12px;
    }

    #debugOut {
      flex: 1;
      margin: 0;
      padding: 10px;
      font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: #0a0f1a;
      color: #d1d5db;
      overflow: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .collapsed #debugOut {
      display: none;
    }

    .footer-note {
      color: var(--muted);
      font-size: 11px;
      margin-top: 8px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
      <h1 style="margin: 16px 0 0;">KTP Weekly Matches Panel</h1>
      <span id="versionBadge" style="font-size: 11px; color: var(--muted); font-family: monospace;">Loading...</span>
    </div>

    <div class="grid">
      <!-- Connection / Secrets -->
      <div class="card" style="grid-column: span 12;">
        <h2>Connection</h2>
        <div class="row">
          <label for="secret">WebApp Secret</label>
          <input id="secret" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" />
          <label><input id="rememberSecret" type="checkbox" /> remember in this browser</label>
          <span id="connStatus" class="pill">idle</span>
        </div>
        <div class="row">
          <button id="btnVerifySecrets" class="btn">Verify Secrets</button>
          <button id="btnState" class="btn">Get State</button>
          <button id="btnProbe" class="btn">Probe Relay</button>
        </div>
        <div class="row" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #374151;">
          <label>Debug Parser</label>
          <label><input id="debugParserToggle" type="checkbox" /> Enable verbose parser logs (üîç, üó∫Ô∏è, üìà)</label>
          <span id="debugStatus" style="font-size: 11px; color: var(--muted); margin-left: 8px;">Loading...</span>
        </div>
        <div class="footer-note">
          Tip: Script properties supported: <code>WEBAPP_SECRET</code>, <code>WEBAPP_SECRET_V2</code>,
          <code>RELAY_SHARED_SECRET</code>, <code>PANEL_SECRET</code>. You can also set <code>DEV_MODE=true</code> and
          <code>SECRET_DEV</code>.
        </div>
      </div>

      <!-- Channel Configuration -->
      <div class="card" style="grid-column: span 12; border: 2px solid var(--warn);">
        <h2>üì° Channel Configuration</h2>
        <div class="footer-note" style="margin-top: 0; margin-bottom: 10px;">
          <strong>Discord Channel IDs:</strong> These Script Properties override the values in 00_config.gs. Update them here to change where the bot posts.
        </div>
        <div class="row">
          <button id="btnLoadChannels" class="btn">üîÑ Load Current Channel IDs</button>
        </div>
        <div class="row">
          <label for="schedChannelId">Schedule Input Channel</label>
          <input id="schedChannelId" type="text" placeholder="e.g. 1234567890123456789" style="flex: 1;" />
          <span style="font-size: 11px; color: var(--muted); margin-left: 8px;">Where captains post schedules</span>
        </div>
        <div class="row">
          <label for="weeklyChannelId">Weekly Post Channel</label>
          <input id="weeklyChannelId" type="text" placeholder="e.g. 1081260197340794920" style="flex: 1;" />
          <span style="font-size: 11px; color: var(--muted); margin-left: 8px;">Where weekly tables are posted</span>
        </div>
        <div class="row">
          <label for="resultsChannelId">Results Log Channel</label>
          <input id="resultsChannelId" type="text" placeholder="e.g. 1234567890123456789" style="flex: 1;" />
          <span style="font-size: 11px; color: var(--muted); margin-left: 8px;">Where results are logged</span>
        </div>
        <div class="row">
          <button id="btnSaveChannels" class="btn ok">üíæ Save Channel IDs</button>
        </div>
      </div>

      <!-- Polling (Current Week Updates) -->
      <div class="card" style="grid-column: span 12;">
        <h2><img src="https://cdn.discordapp.com/emojis/1002382703020212245.png" width="18" height="18" style="vertical-align: middle; margin-right: 6px;" alt="KTP"> Polling (Current Week Updates)</h2>
        <div class="footer-note" style="margin-top: 0; margin-bottom: 10px;">
          <strong>Current week only:</strong> Updates the current/upcoming week table with new schedules. All messages are processed fresh (no skip logic).
        </div>
        <div class="row">
          <label>Last Processed ID</label>
          <span id="lastPollMsgId" style="font-family: monospace; color: #666;">Loading...</span>
          <a id="linkLastPollMsg" href="#" target="_blank" style="margin-left: 8px; font-size: 11px; display: none;">View in Discord</a>
          <button id="btnCopyLastPollId" class="btn" style="margin-left: 8px; font-size: 11px; padding: 4px 8px;">Copy ID</button>
        </div>
        <div class="row">
          <label for="pollStartId">Start Message ID (optional)</label>
          <input id="pollStartId" type="text" placeholder="Leave empty to continue from last" />
        </div>
        <div class="row">
          <button id="btnPollContinue" class="btn ok" style="font-weight: 600;">Continue from Last</button>
          <button id="btnPollFromId" class="btn">Parse from Specific ID</button>
        </div>
      </div>

      <!-- Historical Parsing -->
      <div class="card" style="grid-column: span 12; border: 2px solid var(--ok);">
        <h2>üîÑ Historical Parsing</h2>
        <div class="footer-note" style="margin-top: 0; margin-bottom: 10px;">
          <strong>Recommended for catching up:</strong> Bulk re-parse old Discord messages from captains. Uses message timestamps to match schedules to historical weeks. Useful for back-filling schedules from earlier in the season.
        </div>
        <div class="row">
          <label>Last Processed ID</label>
          <span id="lastHistMsgId" style="font-family: monospace; color: #666;">Loading...</span>
          <a id="linkLastMsg" href="#" target="_blank" style="margin-left: 8px; font-size: 11px; display: none;">üîó View in Discord</a>
          <button id="btnCopyLastId" class="btn" style="margin-left: 8px; font-size: 11px; padding: 4px 8px;">Copy ID</button>
        </div>
        <div class="row">
          <label for="histStartId">Start Message ID (optional)</label>
          <input id="histStartId" type="text" placeholder="Leave empty to continue from last" />
          <label><input id="skipScheduled" type="checkbox" checked /> Skip already-scheduled matches</label>
        </div>
        <div class="row">
          <button id="btnHistContinue" class="btn ok" style="font-weight: 600;">‚ñ∂ Continue from Last</button>
          <button id="btnHistParse" class="btn">Parse from Specific ID</button>
        </div>
      </div>

      <!-- Automatic Polling -->
      <div class="card" style="grid-column: span 12; border: 2px solid var(--accent);">
        <h2>‚è∞ Automatic Polling</h2>
        <div class="footer-note" style="margin-top: 0; margin-bottom: 10px;">
          <strong>Automatic mode:</strong> Set up time-based triggers to automatically poll for new messages and schedule matches. Runs like manual polling but on a timer.
        </div>
        <div class="row">
          <label>Status</label>
          <span id="pollingStatus" class="pill" style="color: var(--muted);">Loading...</span>
          <button id="btnRefreshStatus" class="btn" style="font-size: 11px; padding: 6px 10px;">üîÑ Refresh</button>
        </div>
        <div class="row">
          <label for="pollingInterval">Interval (minutes)</label>
          <input id="pollingInterval" type="number" value="5" min="1" max="60" style="width: 100px;" />
          <span style="font-size: 11px; color: var(--muted);">Recommended: 5 minutes</span>
        </div>
        <div class="row">
          <button id="btnEnablePolling" class="btn ok">‚úÖ Enable Automatic Polling</button>
          <button id="btnDisablePolling" class="btn danger">‚õî Disable Automatic Polling</button>
        </div>
        <div class="row" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #374151;">
          <button id="btnClearScheduled" class="btn warn">üóëÔ∏è Clear All Scheduled Matches</button>
          <span style="font-size: 11px; color: var(--muted); margin-left: 8px;">
            Clears stored schedules to allow re-scheduling. Useful before enabling automatic polling.
          </span>
        </div>
      </div>

      <!-- Weekly Board -->
      <div class="card" style="grid-column: span 12;">
        <h2>Weekly Board</h2>
        <div class="row">
          <button id="btnPost" class="btn ok">Post / Update Weekly Board</button>
          <button id="btnDelete" class="btn danger">Delete Weekly Cluster</button>
          <button id="btnResetIds" class="btn warn">Reset Saved Header/Table IDs</button>
        </div>
        <div class="row">
        </div>
      </div>

      <!-- Clear Week-Specific IDs -->
      <div class="card" style="grid-column: span 12;">
        <h2>üóëÔ∏è Clear Week-Specific Message IDs</h2>
        <div class="footer-note">
          Clear stored Discord message IDs for specific weeks (useful when messages were manually deleted).
        </div>
        <div class="row">
          <button id="btnLoadWeeks" class="btn">üîÑ Load Weeks with Stored IDs</button>
        </div>
        <div class="row">
          <label for="weekSelect">Select Week</label>
          <select id="weekSelect" style="flex: 1;">
            <option value="">-- Load weeks first --</option>
          </select>
        </div>
        <div class="row">
          <label>Stored IDs:</label>
          <div id="weekIdInfo" style="font-size: 11px; color: var(--muted); font-family: monospace; line-height: 1.4;">
            Select a week to see stored IDs
          </div>
        </div>
        <div class="row">
          <button id="btnClearWeekIds" class="btn danger" disabled>Clear Selected Week's IDs</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Debug Dock -->
  <div id="debugDock" class="debug-dock">
    <div class="debug-head">
      <b>debug output</b>
      <div class="debug-actions">
        <button id="dbgToggle" class="btn">Hide</button>
        <button id="dbgCopy" class="btn">Copy</button>
        <button id="dbgClear" class="btn">Clear</button>
      </div>
    </div>
    <pre id="debugOut"></pre>
  </div>

  <script>
    // ---------- tiny DOM helpers ----------
    const $ = (id) => document.getElementById(id);

    // ---------- debug / status helpers ----------
    function nowTs() {
      try {
        return new Date().toLocaleString(undefined, { hour12: true });
      } catch (_){ return new Date().toISOString(); }
    }
    function out(msg, level) {
      const pre = $('debugOut');
      const line = `[${nowTs()}] ${String(msg)}`;
      pre.textContent += (pre.textContent ? '\n' : '') + line;
      pre.scrollTop = pre.scrollHeight;
    }
    function setBusy(isBusy, text) {
      const pill = $('connStatus');
      if (isBusy) {
        pill.textContent = text ? `busy ‚Äî ${text}` : 'busy';
        pill.classList.remove('ok','err'); pill.classList.add('busy');
      } else {
        pill.textContent = 'idle';
        pill.classList.remove('busy','err'); pill.classList.add('ok');
      }
    }
    function setErr(text) {
      const pill = $('connStatus');
      pill.textContent = text || 'error';
      pill.classList.remove('busy','ok'); pill.classList.add('err');
    }

    // ---------- secret persistence ----------
    function sanitizeSecretFieldValue(val) {
      return String(val || '')
        .replace(/[\u200B-\u200D\uFEFF]/g, '')
        .replace(/\s+/g, ' ')
        .replace(/[‚Äú‚Äù]/g, '"').replace(/[‚Äò‚Äô]/g, "'")
        .trim();
    }
    (function loadSecretFromLocalStorage(){
      try {
        const saved = localStorage.getItem('ktp_secret_v2');
        if (saved) {
          $('secret').value = saved;
          $('rememberSecret').checked = true;
        }
      } catch(_) {}
    })();
    $('rememberSecret').addEventListener('change', function() {
      try {
        if (this.checked) {
          localStorage.setItem('ktp_secret_v2', sanitizeSecretFieldValue($('secret').value));
        } else {
          localStorage.removeItem('ktp_secret_v2');
        }
      } catch(_) {}
    });
    $('secret').addEventListener('input', function() {
      if ($('rememberSecret').checked) {
        try { localStorage.setItem('ktp_secret_v2', sanitizeSecretFieldValue(this.value)); } catch(_) {}
      }
    });

    // ---------- button wiring ----------
    // Verify Secrets
    $('btnVerifySecrets').onclick = () => {
      setBusy(true, 'Verifying secrets‚Ä¶'); out('‚ñ∂ Verify Secrets‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        if (res.ok) { out('‚úÖ Verify Secrets result\n' + JSON.stringify(res.data, null, 2), 'ok'); setBusy(false); }
        else { out('‚ùå ' + res.error, 'err'); setErr('bad secret props?'); }
      }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setErr('script error'); })
      .server_verifySecrets();
    };

    // Get State
    $('btnState').onclick = () => {
      setBusy(true, 'Getting state‚Ä¶'); out('‚ñ∂ Get State‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        if (res.ok) out('‚úÖ State\n' + JSON.stringify(res.data, null, 2), 'ok');
        else out('‚ùå ' + res.error, 'err');
        setBusy(false);
      }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
      .server_getState();
    };

    $('btnProbe').onclick = () => {
    const secret = sanitizeSecretFieldValue($('secret').value);
    if (!secret) { out('missing secret','err'); return; }
    setBusy(true, 'Probing relay‚Ä¶'); out('‚ñ∂ Probe Relay‚Ä¶');
    google.script.run.withSuccessHandler(res => {
      out(res.ok ? ('‚úÖ Probe\n' + JSON.stringify(res.data, null, 2)) : ('‚ùå ' + res.error), res.ok ? 'ok' : 'err');
      setBusy(false);
    }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
    .server_probeRelay(secret);
  };

    // ========== Polling (Current Week) ==========

    // Load last polling message ID (shared with historical parsing)
    function loadLastPollingId() {
      google.script.run.withSuccessHandler(res => {
        if (res && res.ok && res.data) {
          const lastId = res.data.lastStartId || 'None';
          const schedChannelId = res.data.schedChannel || '';

          $('lastPollMsgId').textContent = lastId;
          $('lastPollMsgId').style.color = lastId === 'None' ? '#999' : '#2ecc71';

          // Build Discord message link
          if (lastId !== 'None' && schedChannelId && /^\d{17,20}$/.test(lastId)) {
            const guildId = '996884268804493363';
            const discordUrl = 'https://discord.com/channels/' + guildId + '/' + schedChannelId + '/' + lastId;
            $('linkLastPollMsg').href = discordUrl;
            $('linkLastPollMsg').style.display = 'inline';
          } else {
            $('linkLastPollMsg').style.display = 'none';
          }
        }
      }).withFailureHandler(e => {
        $('lastPollMsgId').textContent = 'Error loading';
        $('lastPollMsgId').style.color = '#e74c3c';
        $('linkLastPollMsg').style.display = 'none';
      }).server_getState();
    }

    // Copy polling ID button
    $('btnCopyLastPollId').onclick = async () => {
      const lastId = $('lastPollMsgId').textContent;
      if (lastId === 'None' || lastId === 'Loading...' || lastId === 'Error loading') {
        out('No valid ID to copy', 'err');
        return;
      }
      try {
        await navigator.clipboard.writeText(lastId);
        out('Copied ID: ' + lastId, 'ok');
      } catch (e) {
        out('Failed to copy to clipboard', 'err');
      }
    };

    // Continue from last pointer (current week only, no skip)
    $('btnPollContinue').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('missing secret','err'); return; }

      setBusy(true, 'Loading last pointer...');
      google.script.run.withSuccessHandler(stateRes => {
        if (!stateRes || !stateRes.ok || !stateRes.data || !stateRes.data.lastStartId) {
          out('No last pointer found. Use "Parse from Specific ID" first.', 'err');
          setBusy(false);
          return;
        }

        const lastId = stateRes.data.lastStartId;
        out('Continue polling after ' + lastId + ' (current week, no skip)...');

        google.script.run.withSuccessHandler(res => {
          if (res.ok) {
            const d = res.data;
            out('Polling Complete:\n' +
              '  Processed: ' + (d.processed || 0) + ' messages\n' +
              '  Updated: ' + (d.updated || 0) + ' schedules\n' +
              '  Errors: ' + (d.errors || 0) + '\n' +
              '  Last ID: ' + (d.lastPointer || 'unknown') + '\n' +
              '  Time: ' + (d.tookMs || 0) + 'ms', 'ok');
            loadLastPollingId(); // Refresh
          } else {
            out('Error: ' + res.error, 'err');
          }
          setBusy(false);
        }).withFailureHandler(e => { out('Script error: ' + e.message, 'err'); setBusy(false); })
        .server_startPolling(secret);  // Uses current week, no skip

      }).withFailureHandler(e => { out('Script error: ' + e.message, 'err'); setBusy(false); })
      .server_getState();
    };

    // Parse from specific ID (current week only, no skip)
    $('btnPollFromId').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      const id = $('pollStartId').value.trim();
      if (!secret) { out('Missing secret','err'); return; }
      if (!id) {
        out('Please enter a message ID or use "Continue from Last" button','err');
        return;
      }
      if (!/^\d{5,30}$/.test(id)) { out('Invalid message ID format','err'); return; }

      setBusy(true, 'Polling from specific ID...');
      out('Parse from ' + id + ' (current week, no skip)...');

      google.script.run.withSuccessHandler(res => {
        if (res.ok) {
          const d = res.data;
          out('Polling Complete:\n' +
            '  Processed: ' + (d.processed || 0) + ' messages\n' +
            '  Updated: ' + (d.updated || 0) + ' schedules\n' +
            '  Errors: ' + (d.errors || 0) + '\n' +
            '  Last ID: ' + (d.lastPointer || 'unknown') + '\n' +
            '  Time: ' + (d.tookMs || 0) + 'ms', 'ok');
          loadLastPollingId(); // Refresh
          $('pollStartId').value = ''; // Clear input
        } else {
          out('Error: ' + res.error, 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('Script error: ' + e.message, 'err'); setBusy(false); })
      .server_startPollingFrom(secret, id, false, true);  // skipScheduled=false, inclusive=true
    };

    // Load version badge
    function loadVersionBadge() {
      google.script.run.withSuccessHandler(res => {
        if (res && res.ok && res.data && res.data.version) {
          $('versionBadge').textContent = `v${res.data.version} (${res.data.date})`;
        } else {
          $('versionBadge').textContent = 'Version unknown';
        }
      }).withFailureHandler(e => {
        $('versionBadge').textContent = 'Version error';
      }).server_getVersion();
    }

    // Load last processed message ID on page load
    function loadLastMessageId() {
      google.script.run.withSuccessHandler(res => {
        if (res && res.ok && res.data) {
          const lastId = res.data.lastStartId || 'None';
          const schedChannelId = res.data.schedChannel || '';

          $('lastHistMsgId').textContent = lastId;
          $('lastHistMsgId').style.color = lastId === 'None' ? '#999' : '#2ecc71';

          // Build Discord message link if we have both IDs
          if (lastId !== 'None' && schedChannelId && /^\d{17,20}$/.test(lastId)) {
            // Discord message URL format: https://discord.com/channels/{guild}/{channel}/{message}
            // Using KTP guild ID: 996884268804493363
            const guildId = '996884268804493363';
            const discordUrl = 'https://discord.com/channels/' + guildId + '/' + schedChannelId + '/' + lastId;

            $('linkLastMsg').href = discordUrl;
            $('linkLastMsg').style.display = 'inline';
          } else {
            $('linkLastMsg').style.display = 'none';
          }
        }
      }).withFailureHandler(e => {
        $('lastHistMsgId').textContent = 'Error loading';
        $('lastHistMsgId').style.color = '#e74c3c';
        $('linkLastMsg').style.display = 'none';
      }).server_getState();
    }

    // Load debug parser status on page load
    function loadDebugStatus() {
      google.script.run.withSuccessHandler(res => {
        if (res && res.ok && res.data) {
          const isEnabled = res.data.debugParser || false;
          $('debugParserToggle').checked = isEnabled;
          $('debugStatus').textContent = isEnabled ? 'üü¢ Enabled' : '‚ö™ Disabled';
          $('debugStatus').style.color = isEnabled ? 'var(--ok)' : 'var(--muted)';
        }
      }).withFailureHandler(e => {
        $('debugStatus').textContent = '‚ùå Error';
        $('debugStatus').style.color = 'var(--err)';
      }).server_getDebugStatus();
    }

    // Toggle debug status when checkbox changes
    $('debugParserToggle').onchange = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) {
        out('‚ùå Missing secret', 'err');
        loadDebugStatus(); // Revert checkbox
        return;
      }

      const enabled = $('debugParserToggle').checked;
      $('debugStatus').textContent = '‚è≥ Updating...';

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) {
          const isEnabled = res.data.debugParser;
          $('debugStatus').textContent = isEnabled ? 'üü¢ Enabled' : '‚ö™ Disabled';
          $('debugStatus').style.color = isEnabled ? 'var(--ok)' : 'var(--muted)';
          out(`‚úÖ Debug parser ${isEnabled ? 'enabled' : 'disabled'}`, 'ok');
        } else {
          out('‚ùå Failed to update: ' + res.error, 'err');
          loadDebugStatus(); // Revert checkbox
        }
      }).withFailureHandler(e => {
        out('‚ùå Script error: ' + e.message, 'err');
        loadDebugStatus(); // Revert checkbox
      }).server_setDebugParser(secret, enabled);
    };

    // Load on page load
    loadVersionBadge();
    loadLastMessageId();
    loadLastPollingId();
    loadDebugStatus();

    // Copy Last ID button
    $('btnCopyLastId').onclick = async () => {
      const lastId = $('lastHistMsgId').textContent;
      if (lastId === 'None' || lastId === 'Loading...' || lastId === 'Error loading') {
        out('‚ö†Ô∏è No valid ID to copy', 'err');
        return;
      }
      try {
        await navigator.clipboard.writeText(lastId);
        out('‚úÖ Copied ID: ' + lastId, 'ok');
      } catch (e) {
        out('‚ùå Failed to copy to clipboard', 'err');
      }
    };

    // Parse Historical Messages (from specific ID)
    $('btnHistParse').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      const id = $('histStartId').value.trim();
      const skip = $('skipScheduled').checked;
      if (!secret) { out('‚ùå Missing secret','err'); return; }
      if (!id) {
        out('‚ùå Please enter a message ID or use "Continue from Last" button','err');
        return;
      }
      if (!/^\d{5,30}$/.test(id)) { out('‚ùå Invalid message ID format','err'); return; }
      setBusy(true, 'Parsing historical messages‚Ä¶');
      out('‚ñ∂ Parse Historical Messages from ' + id + ' (inclusive, skipScheduled=' + skip + ')‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        if (res.ok) {
          const d = res.data;
          out('‚úÖ Historical Parse Complete:\n' +
            '  Processed: ' + (d.processed || 0) + ' messages\n' +
            '  Updated: ' + (d.updated || 0) + ' schedules\n' +
            '  Skipped: ' + (d.skipped || 0) + ' (already scheduled)\n' +
            '  Errors: ' + (d.errors || 0) + '\n' +
            '  Last ID: ' + (d.lastPointer || 'unknown') + '\n' +
            '  Time: ' + (d.tookMs || 0) + 'ms', 'ok');
          loadLastMessageId(); // Refresh the displayed ID
          $('histStartId').value = ''; // Clear input after success
        } else {
          out('‚ùå ' + res.error, 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_startPollingFrom(secret, id, skip, true);  // inclusive=true: include the specified message
    };

    // Continue Historical Parsing from last pointer
    $('btnHistContinue').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      const skip = $('skipScheduled').checked;
      if (!secret) { out('missing secret','err'); return; }

      setBusy(true, 'Loading last pointer‚Ä¶');
      google.script.run.withSuccessHandler(stateRes => {
        if (!stateRes || !stateRes.ok || !stateRes.data || !stateRes.data.lastStartId) {
          out('‚ùå No last pointer found. Use "Parse Historical Messages" first.', 'err');
          setBusy(false);
          return;
        }

        const lastId = stateRes.data.lastStartId;
        out('‚ñ∂ Continue Historical Parsing after ' + lastId + ' (exclusive, skipScheduled=' + skip + ')‚Ä¶');

        google.script.run.withSuccessHandler(res => {
          if (res.ok) {
            const d = res.data;
            out('‚úÖ Historical Parse Complete:\n' +
              '  Processed: ' + (d.processed || 0) + ' messages\n' +
              '  Updated: ' + (d.updated || 0) + ' schedules\n' +
              '  Skipped: ' + (d.skipped || 0) + ' (already scheduled)\n' +
              '  Errors: ' + (d.errors || 0) + '\n' +
              '  Last ID: ' + (d.lastPointer || 'unknown') + '\n' +
              '  Time: ' + (d.tookMs || 0) + 'ms', 'ok');
            loadLastMessageId(); // Refresh the displayed ID
          } else {
            out('‚ùå ' + res.error, 'err');
          }
          setBusy(false);
        }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
        .server_startPollingFrom(secret, lastId, skip, false);  // inclusive=false: don't reprocess last message

      }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
      .server_getState();
    };

    // Post / Update Weekly Board
    $('btnPost').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('missing secret','err'); return; }
      setBusy(true, 'Posting/updating weekly board‚Ä¶'); out('‚ñ∂ Post/Update Weekly Board‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        out(res.ok ? ('‚úÖ done: ' + JSON.stringify(res.data)) : ('‚ùå ' + res.error), res.ok ? 'ok' : 'err');
        setBusy(false);
      }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
      .server_postOrUpdate(secret);
    };

    // Delete Weekly Cluster (with confirmation)
    $('btnDelete').onclick = () => {
      if (!confirm('‚ö†Ô∏è Are you sure you want to DELETE the entire weekly cluster from Discord?\n\nThis will remove all weekly board messages and cannot be undone.')) {
        out('‚ùå Delete cancelled', 'err');
        return;
      }
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }
      setBusy(true, 'Deleting weekly cluster‚Ä¶');
      out('‚ñ∂ Delete Weekly Cluster‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        out(res.ok ? '‚úÖ Deleted' : ('‚ùå ' + res.error), res.ok ? 'ok' : 'err');
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_deleteWeeklyCluster(secret);
    };

    // Reset saved message IDs (with confirmation)
    $('btnResetIds').onclick = () => {
      if (!confirm('‚ö†Ô∏è Reset saved Discord message IDs?\n\nThis will clear stored header/table message IDs. The next post will create new messages instead of editing existing ones.')) {
        out('‚ùå Reset cancelled', 'err');
        return;
      }
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }
      setBusy(true, 'Resetting saved IDs‚Ä¶');
      out('‚ñ∂ Reset Saved IDs‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) out('‚úÖ IDs reset', 'ok');
        else out('‚ùå ' + (res && res.error), 'err');
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_resetMsgIdsForCurrent(secret);
    };

    // Week-specific ID management
    let weeksData = []; // Store loaded weeks data

    $('btnLoadWeeks').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }

      setBusy(true, 'Loading weeks‚Ä¶');
      out('‚ñ∂ Loading weeks with stored message IDs‚Ä¶');

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok && res.data && res.data.weeks) {
          weeksData = res.data.weeks;
          const select = $('weekSelect');
          select.innerHTML = '<option value="">-- Select a week --</option>';

          if (weeksData.length === 0) {
            select.innerHTML = '<option value="">-- No weeks with stored IDs --</option>';
            out('‚ÑπÔ∏è No weeks found with stored message IDs', 'ok');
          } else {
            weeksData.forEach(w => {
              const option = document.createElement('option');
              option.value = w.weekKey;
              option.textContent = w.weekKey;
              select.appendChild(option);
            });
            out(`‚úÖ Loaded ${weeksData.length} week(s) with stored IDs`, 'ok');
          }

          $('weekIdInfo').textContent = 'Select a week to see stored IDs';
          $('btnClearWeekIds').disabled = true;
        } else {
          out('‚ùå ' + (res && res.error), 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_listWeeksWithMessageIds(secret);
    };

    $('weekSelect').onchange = () => {
      const weekKey = $('weekSelect').value;
      if (!weekKey) {
        $('weekIdInfo').textContent = 'Select a week to see stored IDs';
        $('btnClearWeekIds').disabled = true;
        return;
      }

      const week = weeksData.find(w => w.weekKey === weekKey);
      if (week && week.ids) {
        const lines = [];
        if (week.ids.header) lines.push(`Header: ${week.ids.header}`);
        if (week.ids.table) lines.push(`Table: ${week.ids.table}`);
        if (week.ids.rematch) lines.push(`Rematch: ${week.ids.rematch}`);

        $('weekIdInfo').innerHTML = lines.length > 0 ? lines.join('<br>') : 'No IDs found';
        $('btnClearWeekIds').disabled = false;
      } else {
        $('weekIdInfo').textContent = 'No IDs found for this week';
        $('btnClearWeekIds').disabled = true;
      }
    };

    $('btnClearWeekIds').onclick = () => {
      const weekKey = $('weekSelect').value;
      if (!weekKey) { out('‚ùå No week selected','err'); return; }

      if (!confirm(`‚ö†Ô∏è Clear stored message IDs for week "${weekKey}"?\n\nThis will force new Discord messages to be created next time this week is updated.`)) {
        out('‚ùå Clear cancelled', 'err');
        return;
      }

      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }

      setBusy(true, `Clearing IDs for ${weekKey}‚Ä¶`);
      out(`‚ñ∂ Clearing message IDs for week ${weekKey}‚Ä¶`);

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) {
          out(`‚úÖ Cleared IDs for ${weekKey}`, 'ok');
          // Reload the week list
          $('btnLoadWeeks').click();
        } else {
          out('‚ùå ' + (res && res.error), 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_resetMsgIdsForWeek(secret, weekKey);
    };

    // Debug dock controls
    $('dbgToggle').onclick = () => {
      $('debugDock').classList.toggle('collapsed');
      $('dbgToggle').textContent = $('debugDock').classList.contains('collapsed') ? 'Show' : 'Hide';
    };
    $('dbgCopy').onclick = async () => {
      try {
        await navigator.clipboard.writeText($('debugOut').textContent);
      } catch (e) {}
    };
    $('dbgClear').onclick = () => { $('debugOut').textContent = ''; };

    // ========== Channel Configuration ==========

    // Load current channel IDs
    $('btnLoadChannels').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }

      setBusy(true, 'Loading channel IDs...');
      out('‚ñ∂ Loading channel IDs...');

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok && res.data) {
          $('schedChannelId').value = res.data.schedChannel || '';
          $('weeklyChannelId').value = res.data.weeklyChannel || '';
          $('resultsChannelId').value = res.data.resultsChannel || '';
          out('‚úÖ Channel IDs loaded:\n' +
            '  Schedule Input: ' + (res.data.schedChannel || '(not set)') + '\n' +
            '  Weekly Post: ' + (res.data.weeklyChannel || '(not set)') + '\n' +
            '  Results Log: ' + (res.data.resultsChannel || '(not set)'), 'ok');
        } else {
          out('‚ùå ' + (res && res.error), 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_getChannelIds(secret);
    };

    // Save channel IDs
    $('btnSaveChannels').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }

      const schedId = $('schedChannelId').value.trim();
      const weeklyId = $('weeklyChannelId').value.trim();
      const resultsId = $('resultsChannelId').value.trim();

      // Validate IDs
      const validate = (id, name) => {
        if (id && !/^\d{17,20}$/.test(id)) {
          out('‚ùå Invalid ' + name + ' ID format (must be 17-20 digits)', 'err');
          return false;
        }
        return true;
      };

      if (!validate(schedId, 'Schedule Input Channel')) return;
      if (!validate(weeklyId, 'Weekly Post Channel')) return;
      if (!validate(resultsId, 'Results Log Channel')) return;

      if (!confirm('Save Channel IDs?\n\n' +
        'Schedule Input: ' + (schedId || '(empty)') + '\n' +
        'Weekly Post: ' + (weeklyId || '(empty)') + '\n' +
        'Results Log: ' + (resultsId || '(empty)') + '\n\n' +
        'This will update Script Properties immediately.')) {
        out('‚ùå Save cancelled', 'err');
        return;
      }

      setBusy(true, 'Saving channel IDs...');
      out('‚ñ∂ Saving channel IDs...');

      const channels = {
        schedChannel: schedId,
        weeklyChannel: weeklyId,
        resultsChannel: resultsId
      };

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) {
          out('‚úÖ Channel IDs saved:\n  Updated: ' + res.data.updated.join(', '), 'ok');
        } else {
          out('‚ùå ' + (res && res.error), 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_setChannelIds(secret, channels);
    };

    // ========== Automatic Polling Management ==========

    // Load polling status on page load and update UI
    function loadPollingStatus() {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) {
        $('pollingStatus').textContent = 'Enter secret first';
        $('pollingStatus').style.color = 'var(--muted)';
        return;
      }

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok && res.data) {
          const enabled = res.data.enabled;
          const count = res.data.count || 0;

          if (enabled) {
            $('pollingStatus').textContent = 'Enabled (' + count + ' trigger' + (count !== 1 ? 's' : '') + ')';
            $('pollingStatus').style.color = 'var(--ok)';
            $('pollingStatus').style.borderColor = 'var(--ok)';
          } else {
            $('pollingStatus').textContent = 'Disabled';
            $('pollingStatus').style.color = 'var(--muted)';
            $('pollingStatus').style.borderColor = '#374151';
          }
        } else {
          $('pollingStatus').textContent = 'Error';
          $('pollingStatus').style.color = 'var(--err)';
        }
      }).withFailureHandler(e => {
        $('pollingStatus').textContent = 'Error: ' + e.message;
        $('pollingStatus').style.color = 'var(--err)';
      }).server_getPollingStatus(secret);
    }

    // Refresh status button
    $('btnRefreshStatus').onclick = () => {
      out('‚ñ∂ Refreshing polling status...');
      loadPollingStatus();
    };

    // Enable automatic polling
    $('btnEnablePolling').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }

      const interval = parseInt($('pollingInterval').value) || 5;
      if (interval < 1 || interval > 60) {
        out('‚ùå Interval must be between 1 and 60 minutes', 'err');
        return;
      }

      if (!confirm('‚úÖ Enable automatic polling?\n\nInterval: Every ' + interval + ' minute' + (interval !== 1 ? 's' : '') + '\nBehavior: Polls from last pointer, allows re-scheduling\n\nThis will create a time-based trigger that runs automatically.')) {
        out('‚ùå Enable cancelled', 'err');
        return;
      }

      setBusy(true, 'Enabling polling...');
      out('Enabling automatic polling (' + interval + ' minute interval)...');

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) {
          out('Automatic polling enabled:\n  Trigger ID: ' + res.data.triggerId + '\n  Interval: ' + res.data.interval + ' minutes', 'ok');
          loadPollingStatus(); // Refresh status
        } else {
          out('Error: ' + (res && res.error), 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('Script error: ' + e.message, 'err'); setBusy(false); })
      .server_enablePolling(secret, interval);
    };

    // Disable automatic polling
    $('btnDisablePolling').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('Missing secret','err'); return; }

      if (!confirm('Disable automatic polling?\n\nThis will remove all automatic polling triggers. You can re-enable it anytime.')) {
        out('Disable cancelled', 'err');
        return;
      }

      setBusy(true, 'Disabling polling...');
      out('Disabling automatic polling...');

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) {
          out('Automatic polling disabled:\n  Triggers removed: ' + res.data.removed, 'ok');
          loadPollingStatus(); // Refresh status
        } else {
          out('Error: ' + (res && res.error), 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('Script error: ' + e.message, 'err'); setBusy(false); })
      .server_disablePolling(secret);
    };

    // Clear all scheduled matches
    $('btnClearScheduled').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('Missing secret','err'); return; }

      if (!confirm('Clear all scheduled matches from the store?\n\nThis will:\n- Remove all stored schedule data from ALL weeks\n- Keep other data (shoutcasters, etc.) intact\n- Allow re-scheduling of all matches\n\nUseful before enabling automatic polling to ensure all matches get fresh schedules.')) {
        out('Clear cancelled', 'err');
        return;
      }

      setBusy(true, 'Clearing schedules...');
      out('Clearing all scheduled matches...');

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) {
          out('Cleared schedules from ' + res.data.cleared + ' week store(s)', 'ok');
        } else {
          out('Error: ' + (res && res.error), 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('Script error: ' + e.message, 'err'); setBusy(false); })
      .server_clearAllScheduled(secret);
    };

    // Load polling status when secret is entered
    $('secret').addEventListener('blur', loadPollingStatus);

    // Load polling status on page load (after a short delay to let secret load from localStorage)
    setTimeout(loadPollingStatus, 500);


  </script>
</body>
</html>