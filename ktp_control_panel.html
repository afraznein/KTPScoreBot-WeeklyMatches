<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>KTP Weekly Matches Panel</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --card: #1f2937;
      --muted: #9CA3AF;
      --ok: #22c55e;
      --err: #ef4444;
      --warn: #f59e0b;
      --txt: #e5e7eb;
      --accent: #60a5fa;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--txt);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }

    h1 {
      margin: 16px 0 12px;
      font-size: 22px;
    }

    h2 {
      margin: 14px 0 8px;
      font-size: 16px;
      color: var(--muted);
      font-weight: 600;
    }

    .wrap {
      max-width: 1080px;
      margin: 0 auto;
      padding: 16px 20px 120px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
    }

    .card {
      background: var(--card);
      border: 1px solid #374151;
      border-radius: 10px;
      padding: 12px;
      box-shadow: 0 1px 0 rgb(255 255 255 / 0.02) inset, 0 8px 24px rgb(0 0 0 / 0.25);
    }

    .card h2 {
      margin-top: 2px;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin: 6px 0;
    }

    .row label {
      font-size: 12px;
      color: var(--muted);
      margin-right: 6px;
    }

    .row input[type="text"],
    .row input[type="password"] {
      background: #0b1220;
      color: var(--txt);
      border: 1px solid #334155;
      padding: 8px 10px;
      border-radius: 8px;
      min-width: 220px;
      outline: none;
    }

    .row input[type="checkbox"] {
      transform: translateY(1px);
    }

    .btn {
      background: #0b1220;
      color: var(--txt);
      border: 1px solid #3b82f6;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    .btn:hover {
      background: #0b1529;
    }

    .btn.warn {
      border-color: var(--warn);
      color: #fff;
    }

    .btn.danger {
      border-color: var(--err);
      color: #fff;
    }

    .btn.ok {
      border-color: var(--ok);
    }

    .pill {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: .3px;
      border: 1px solid #374151;
      background: #0b1220;
      color: var(--muted);
    }

    .status {
      margin-left: 8px;
    }

    .status.ok {
      color: var(--ok);
      border-color: var(--ok);
    }

    .status.err {
      color: var(--err);
      border-color: var(--err);
    }

    .status.busy {
      color: var(--warn);
      border-color: var(--warn);
    }

    /* Debug dock (fixed, top-right) */
    .debug-dock {
      position: fixed;
      right: 16px;
      top: 16px;
      bottom: 16px;
      width: 420px;
      background: var(--panel);
      border: 1px solid #374151;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      z-index: 9999;
      box-shadow: 0 8px 28px rgba(0, 0, 0, .35);
    }

    .debug-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      border-bottom: 1px solid #30363d;
      background: #0b1220;
    }

    .debug-head b {
      font-size: 12px;
      color: var(--muted);
    }

    .debug-actions {
      display: flex;
      gap: 6px;
    }

    .debug-actions .btn {
      padding: 6px 8px;
      font-size: 12px;
    }

    #debugOut {
      flex: 1;
      margin: 0;
      padding: 10px;
      font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: #0a0f1a;
      color: #d1d5db;
      overflow: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .collapsed #debugOut {
      display: none;
    }

    .footer-note {
      color: var(--muted);
      font-size: 11px;
      margin-top: 8px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
      <h1 style="margin: 16px 0 0;">KTP Weekly Matches Panel</h1>
      <span id="versionBadge" style="font-size: 11px; color: var(--muted); font-family: monospace;">Loading...</span>
    </div>

    <div class="grid">
      <!-- Connection / Secrets -->
      <div class="card" style="grid-column: span 12;">
        <h2>Connection</h2>
        <div class="row">
          <label for="secret">WebApp Secret</label>
          <input id="secret" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" />
          <label><input id="rememberSecret" type="checkbox" /> remember in this browser</label>
          <span id="connStatus" class="pill">idle</span>
        </div>
        <div class="row">
          <button id="btnVerifySecrets" class="btn">Verify Secrets</button>
          <button id="btnState" class="btn">Get State</button>
          <button id="btnProbe" class="btn">Probe Relay</button>
        </div>
        <div class="row" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #374151;">
          <label>Debug Parser</label>
          <label><input id="debugParserToggle" type="checkbox" /> Enable verbose parser logs (üîç, üó∫Ô∏è, üìà)</label>
          <span id="debugStatus" style="font-size: 11px; color: var(--muted); margin-left: 8px;">Loading...</span>
        </div>
        <div class="footer-note">
          Tip: Script properties supported: <code>WEBAPP_SECRET</code>, <code>WEBAPP_SECRET_V2</code>,
          <code>RELAY_SHARED_SECRET</code>, <code>PANEL_SECRET</code>. You can also set <code>DEV_MODE=true</code> and
          <code>SECRET_DEV</code>.
        </div>
      </div>

      <!-- Polling -->
      <div class="card" style="grid-column: span 12;">
        <h2>Polling</h2>
        <div class="row">
          <label for="startId">Start Message ID</label>
          <input id="startId" type="text" placeholder="e.g. 1423841447026622534" />
        </div>
        <div class="row">
          <button id="btnSet" class="btn">Set Start ID</button>
          <button id="btnClear" class="btn warn">Clear Start ID</button>
          <button id="btnStart" class="btn ok">Start Polling (from ID, inclusive)</button>
          <button id="btnStartPointer" class="btn">Start (from last pointer)</button>
        </div>
      </div>

      <!-- Historical Parsing (Primary Parser) -->
      <div class="card" style="grid-column: span 12; border: 2px solid var(--ok);">
        <h2>üîÑ Historical Parsing (Primary Parser)</h2>
        <div class="footer-note" style="margin-top: 0; margin-bottom: 10px;">
          <strong>Recommended for catching up:</strong> Bulk re-parse old Discord messages from captains. Uses message timestamps to match schedules to historical weeks. Useful for back-filling schedules from earlier in the season.
        </div>
        <div class="row">
          <label>Last Processed ID</label>
          <span id="lastHistMsgId" style="font-family: monospace; color: #666;">Loading...</span>
          <button id="btnCopyLastId" class="btn" style="margin-left: 8px; font-size: 11px; padding: 4px 8px;">Copy ID</button>
        </div>
        <div class="row">
          <label for="histStartId">Start Message ID (optional)</label>
          <input id="histStartId" type="text" placeholder="Leave empty to continue from last" />
          <label><input id="skipScheduled" type="checkbox" checked /> Skip already-scheduled matches</label>
        </div>
        <div class="row">
          <button id="btnHistContinue" class="btn ok" style="font-weight: 600;">‚ñ∂ Continue from Last</button>
          <button id="btnHistParse" class="btn">Parse from Specific ID</button>
        </div>
      </div>

      <!-- Automatic Polling -->
      <div class="card" style="grid-column: span 12; border: 2px solid var(--accent);">
        <h2>‚è∞ Automatic Polling</h2>
        <div class="footer-note" style="margin-top: 0; margin-bottom: 10px;">
          <strong>Automatic mode:</strong> Set up time-based triggers to automatically poll for new messages and schedule matches. Runs like manual polling but on a timer.
        </div>
        <div class="row">
          <label>Status</label>
          <span id="pollingStatus" class="pill" style="color: var(--muted);">Loading...</span>
          <button id="btnRefreshStatus" class="btn" style="font-size: 11px; padding: 6px 10px;">üîÑ Refresh</button>
        </div>
        <div class="row">
          <label for="pollingInterval">Interval (minutes)</label>
          <input id="pollingInterval" type="number" value="5" min="1" max="60" style="width: 100px;" />
          <span style="font-size: 11px; color: var(--muted);">Recommended: 5 minutes</span>
        </div>
        <div class="row">
          <button id="btnEnablePolling" class="btn ok">‚úÖ Enable Automatic Polling</button>
          <button id="btnDisablePolling" class="btn danger">‚õî Disable Automatic Polling</button>
        </div>
        <div class="row" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #374151;">
          <button id="btnClearScheduled" class="btn warn">üóëÔ∏è Clear All Scheduled Matches</button>
          <span style="font-size: 11px; color: var(--muted); margin-left: 8px;">
            Clears stored schedules to allow re-scheduling. Useful before enabling automatic polling.
          </span>
        </div>
      </div>

      <!-- Weekly Board -->
      <div class="card" style="grid-column: span 12;">
        <h2>Weekly Board</h2>
        <div class="row">
          <button id="btnPost" class="btn ok">Post / Update Weekly Board</button>
          <button id="btnDelete" class="btn danger">Delete Weekly Cluster</button>
          <button id="btnResetIds" class="btn warn">Reset Saved Header/Table IDs</button>
        </div>
        <div class="row">
        </div>
      </div>

      <!-- Clear Week-Specific IDs -->
      <div class="card" style="grid-column: span 6;">
        <h2>üóëÔ∏è Clear Week-Specific Message IDs</h2>
        <div class="footer-note">
          Clear stored Discord message IDs for specific weeks (useful when messages were manually deleted).
        </div>
        <div class="row">
          <button id="btnLoadWeeks" class="btn">üîÑ Load Weeks with Stored IDs</button>
        </div>
        <div class="row">
          <label for="weekSelect">Select Week</label>
          <select id="weekSelect" style="flex: 1;">
            <option value="">-- Load weeks first --</option>
          </select>
        </div>
        <div class="row">
          <label>Stored IDs:</label>
          <div id="weekIdInfo" style="font-size: 11px; color: var(--muted); font-family: monospace; line-height: 1.4;">
            Select a week to see stored IDs
          </div>
        </div>
        <div class="row">
          <button id="btnClearWeekIds" class="btn danger" disabled>Clear Selected Week's IDs</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Debug Dock -->
  <div id="debugDock" class="debug-dock">
    <div class="debug-head">
      <b>debug output</b>
      <div class="debug-actions">
        <button id="dbgToggle" class="btn">Hide</button>
        <button id="dbgCopy" class="btn">Copy</button>
        <button id="dbgClear" class="btn">Clear</button>
      </div>
    </div>
    <pre id="debugOut"></pre>
  </div>

  <script>
    // ---------- tiny DOM helpers ----------
    const $ = (id) => document.getElementById(id);

    // ---------- debug / status helpers ----------
    function nowTs() {
      try {
        return new Date().toLocaleString(undefined, { hour12: true });
      } catch (_){ return new Date().toISOString(); }
    }
    function out(msg, level) {
      const pre = $('debugOut');
      const line = `[${nowTs()}] ${String(msg)}`;
      pre.textContent += (pre.textContent ? '\n' : '') + line;
      pre.scrollTop = pre.scrollHeight;
    }
    function setBusy(isBusy, text) {
      const pill = $('connStatus');
      if (isBusy) {
        pill.textContent = text ? `busy ‚Äî ${text}` : 'busy';
        pill.classList.remove('ok','err'); pill.classList.add('busy');
      } else {
        pill.textContent = 'idle';
        pill.classList.remove('busy','err'); pill.classList.add('ok');
      }
    }
    function setErr(text) {
      const pill = $('connStatus');
      pill.textContent = text || 'error';
      pill.classList.remove('busy','ok'); pill.classList.add('err');
    }

    // ---------- secret persistence ----------
    function sanitizeSecretFieldValue(val) {
      return String(val || '')
        .replace(/[\u200B-\u200D\uFEFF]/g, '')
        .replace(/\s+/g, ' ')
        .replace(/[‚Äú‚Äù]/g, '"').replace(/[‚Äò‚Äô]/g, "'")
        .trim();
    }
    (function loadSecretFromLocalStorage(){
      try {
        const saved = localStorage.getItem('ktp_secret_v2');
        if (saved) {
          $('secret').value = saved;
          $('rememberSecret').checked = true;
        }
      } catch(_) {}
    })();
    $('rememberSecret').addEventListener('change', function() {
      try {
        if (this.checked) {
          localStorage.setItem('ktp_secret_v2', sanitizeSecretFieldValue($('secret').value));
        } else {
          localStorage.removeItem('ktp_secret_v2');
        }
      } catch(_) {}
    });
    $('secret').addEventListener('input', function() {
      if ($('rememberSecret').checked) {
        try { localStorage.setItem('ktp_secret_v2', sanitizeSecretFieldValue(this.value)); } catch(_) {}
      }
    });

    // ---------- button wiring ----------
    // Verify Secrets
    $('btnVerifySecrets').onclick = () => {
      setBusy(true, 'Verifying secrets‚Ä¶'); out('‚ñ∂ Verify Secrets‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        if (res.ok) { out('‚úÖ Verify Secrets result\n' + JSON.stringify(res.data, null, 2), 'ok'); setBusy(false); }
        else { out('‚ùå ' + res.error, 'err'); setErr('bad secret props?'); }
      }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setErr('script error'); })
      .server_verifySecrets();
    };

    // Get State
    $('btnState').onclick = () => {
      setBusy(true, 'Getting state‚Ä¶'); out('‚ñ∂ Get State‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        if (res.ok) out('‚úÖ State\n' + JSON.stringify(res.data, null, 2), 'ok');
        else out('‚ùå ' + res.error, 'err');
        setBusy(false);
      }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
      .server_getState();
    };

    $('btnProbe').onclick = () => {
    const secret = sanitizeSecretFieldValue($('secret').value);
    if (!secret) { out('missing secret','err'); return; }
    setBusy(true, 'Probing relay‚Ä¶'); out('‚ñ∂ Probe Relay‚Ä¶');
    google.script.run.withSuccessHandler(res => {
      out(res.ok ? ('‚úÖ Probe\n' + JSON.stringify(res.data, null, 2)) : ('‚ùå ' + res.error), res.ok ? 'ok' : 'err');
      setBusy(false);
    }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
    .server_probeRelay(secret);
  };

    // Set Start ID
    $('btnSet').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      const id = $('startId').value.trim();
      if (!secret) { out('missing secret','err'); return; }
      if (!/^\d{5,30}$/.test(id)) { out('invalid message id','err'); return; }
      setBusy(true, 'Setting start id‚Ä¶'); out('‚ñ∂ Set Start ID‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        out(res.ok ? ('‚úÖ set: ' + JSON.stringify(res.data)) : ('‚ùå ' + res.error), res.ok ? 'ok':'err');
        setBusy(false);
      }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
      .server_setStartId(secret, id);
    };

    // Clear Start ID
    $('btnClear').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('missing secret','err'); return; }
      setBusy(true, 'Clearing start id‚Ä¶'); out('‚ñ∂ Clear Start ID‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        out(res.ok ? '‚úÖ cleared' : ('‚ùå ' + res.error), res.ok ? 'ok' : 'err');
        setBusy(false);
      }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
      .server_clearStartId(secret);
    };

    // Start Polling (inclusive)
    $('btnStart').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      const id = $('startId').value.trim();
      if (!secret) { out('missing secret','err'); return; }
      if (!/^\d{5,30}$/.test(id)) { out('invalid message id','err'); return; }
      setBusy(true, 'Polling from ID (inclusive)‚Ä¶'); out('‚ñ∂ Start Polling from ID (inclusive)‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        out(res.ok ? ('‚úÖ ' + JSON.stringify(res.data)) : ('‚ùå ' + res.error), res.ok ? 'ok' : 'err');
        setBusy(false);
      }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
      .server_startPollingFrom(secret, id);
    };

    // Start Polling (from last pointer)
    $('btnStartPointer').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('missing secret','err'); return; }
      setBusy(true, 'Polling from last pointer‚Ä¶'); out('‚ñ∂ Start Polling from last pointer‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        out(res.ok ? ('‚úÖ ' + JSON.stringify(res.data)) : ('‚ùå ' + res.error), res.ok ? 'ok' : 'err');
        setBusy(false);
      }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
      .server_startPolling(secret);
    };

    // Load version badge
    function loadVersionBadge() {
      google.script.run.withSuccessHandler(res => {
        if (res && res.ok && res.data && res.data.version) {
          $('versionBadge').textContent = `v${res.data.version} (${res.data.date})`;
        } else {
          $('versionBadge').textContent = 'Version unknown';
        }
      }).withFailureHandler(e => {
        $('versionBadge').textContent = 'Version error';
      }).server_getVersion();
    }

    // Load last processed message ID on page load
    function loadLastMessageId() {
      google.script.run.withSuccessHandler(res => {
        if (res && res.ok && res.data) {
          const lastId = res.data.lastStartId || 'None';
          $('lastHistMsgId').textContent = lastId;
          $('lastHistMsgId').style.color = lastId === 'None' ? '#999' : '#2ecc71';
        }
      }).withFailureHandler(e => {
        $('lastHistMsgId').textContent = 'Error loading';
        $('lastHistMsgId').style.color = '#e74c3c';
      }).server_getState();
    }

    // Load debug parser status on page load
    function loadDebugStatus() {
      google.script.run.withSuccessHandler(res => {
        if (res && res.ok && res.data) {
          const isEnabled = res.data.debugParser || false;
          $('debugParserToggle').checked = isEnabled;
          $('debugStatus').textContent = isEnabled ? 'üü¢ Enabled' : '‚ö™ Disabled';
          $('debugStatus').style.color = isEnabled ? 'var(--ok)' : 'var(--muted)';
        }
      }).withFailureHandler(e => {
        $('debugStatus').textContent = '‚ùå Error';
        $('debugStatus').style.color = 'var(--err)';
      }).server_getDebugStatus();
    }

    // Toggle debug status when checkbox changes
    $('debugParserToggle').onchange = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) {
        out('‚ùå Missing secret', 'err');
        loadDebugStatus(); // Revert checkbox
        return;
      }

      const enabled = $('debugParserToggle').checked;
      $('debugStatus').textContent = '‚è≥ Updating...';

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) {
          const isEnabled = res.data.debugParser;
          $('debugStatus').textContent = isEnabled ? 'üü¢ Enabled' : '‚ö™ Disabled';
          $('debugStatus').style.color = isEnabled ? 'var(--ok)' : 'var(--muted)';
          out(`‚úÖ Debug parser ${isEnabled ? 'enabled' : 'disabled'}`, 'ok');
        } else {
          out('‚ùå Failed to update: ' + res.error, 'err');
          loadDebugStatus(); // Revert checkbox
        }
      }).withFailureHandler(e => {
        out('‚ùå Script error: ' + e.message, 'err');
        loadDebugStatus(); // Revert checkbox
      }).server_setDebugParser(secret, enabled);
    };

    // Load on page load
    loadVersionBadge();
    loadLastMessageId();
    loadDebugStatus();

    // Copy Last ID button
    $('btnCopyLastId').onclick = async () => {
      const lastId = $('lastHistMsgId').textContent;
      if (lastId === 'None' || lastId === 'Loading...' || lastId === 'Error loading') {
        out('‚ö†Ô∏è No valid ID to copy', 'err');
        return;
      }
      try {
        await navigator.clipboard.writeText(lastId);
        out('‚úÖ Copied ID: ' + lastId, 'ok');
      } catch (e) {
        out('‚ùå Failed to copy to clipboard', 'err');
      }
    };

    // Parse Historical Messages (from specific ID)
    $('btnHistParse').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      const id = $('histStartId').value.trim();
      const skip = $('skipScheduled').checked;
      if (!secret) { out('‚ùå Missing secret','err'); return; }
      if (!id) {
        out('‚ùå Please enter a message ID or use "Continue from Last" button','err');
        return;
      }
      if (!/^\d{5,30}$/.test(id)) { out('‚ùå Invalid message ID format','err'); return; }
      setBusy(true, 'Parsing historical messages‚Ä¶');
      out('‚ñ∂ Parse Historical Messages from ' + id + ' (inclusive, skipScheduled=' + skip + ')‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        if (res.ok) {
          const d = res.data;
          out('‚úÖ Historical Parse Complete:\n' +
            '  Processed: ' + (d.processed || 0) + ' messages\n' +
            '  Updated: ' + (d.updated || 0) + ' schedules\n' +
            '  Skipped: ' + (d.skipped || 0) + ' (already scheduled)\n' +
            '  Errors: ' + (d.errors || 0) + '\n' +
            '  Last ID: ' + (d.lastPointer || 'unknown') + '\n' +
            '  Time: ' + (d.tookMs || 0) + 'ms', 'ok');
          loadLastMessageId(); // Refresh the displayed ID
          $('histStartId').value = ''; // Clear input after success
        } else {
          out('‚ùå ' + res.error, 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_startPollingFrom(secret, id, skip, true);  // inclusive=true: include the specified message
    };

    // Continue Historical Parsing from last pointer
    $('btnHistContinue').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      const skip = $('skipScheduled').checked;
      if (!secret) { out('missing secret','err'); return; }

      setBusy(true, 'Loading last pointer‚Ä¶');
      google.script.run.withSuccessHandler(stateRes => {
        if (!stateRes || !stateRes.ok || !stateRes.data || !stateRes.data.lastStartId) {
          out('‚ùå No last pointer found. Use "Parse Historical Messages" first.', 'err');
          setBusy(false);
          return;
        }

        const lastId = stateRes.data.lastStartId;
        out('‚ñ∂ Continue Historical Parsing after ' + lastId + ' (exclusive, skipScheduled=' + skip + ')‚Ä¶');

        google.script.run.withSuccessHandler(res => {
          if (res.ok) {
            const d = res.data;
            out('‚úÖ Historical Parse Complete:\n' +
              '  Processed: ' + (d.processed || 0) + ' messages\n' +
              '  Updated: ' + (d.updated || 0) + ' schedules\n' +
              '  Skipped: ' + (d.skipped || 0) + ' (already scheduled)\n' +
              '  Errors: ' + (d.errors || 0) + '\n' +
              '  Last ID: ' + (d.lastPointer || 'unknown') + '\n' +
              '  Time: ' + (d.tookMs || 0) + 'ms', 'ok');
            loadLastMessageId(); // Refresh the displayed ID
          } else {
            out('‚ùå ' + res.error, 'err');
          }
          setBusy(false);
        }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
        .server_startPollingFrom(secret, lastId, skip, false);  // inclusive=false: don't reprocess last message

      }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
      .server_getState();
    };

    // Post / Update Weekly Board
    $('btnPost').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('missing secret','err'); return; }
      setBusy(true, 'Posting/updating weekly board‚Ä¶'); out('‚ñ∂ Post/Update Weekly Board‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        out(res.ok ? ('‚úÖ done: ' + JSON.stringify(res.data)) : ('‚ùå ' + res.error), res.ok ? 'ok' : 'err');
        setBusy(false);
      }).withFailureHandler(e => { out('script error: ' + e.message, 'err'); setBusy(false); })
      .server_postOrUpdate(secret);
    };

    // Delete Weekly Cluster (with confirmation)
    $('btnDelete').onclick = () => {
      if (!confirm('‚ö†Ô∏è Are you sure you want to DELETE the entire weekly cluster from Discord?\n\nThis will remove all weekly board messages and cannot be undone.')) {
        out('‚ùå Delete cancelled', 'err');
        return;
      }
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }
      setBusy(true, 'Deleting weekly cluster‚Ä¶');
      out('‚ñ∂ Delete Weekly Cluster‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        out(res.ok ? '‚úÖ Deleted' : ('‚ùå ' + res.error), res.ok ? 'ok' : 'err');
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_deleteWeeklyCluster(secret);
    };

    // Reset saved message IDs (with confirmation)
    $('btnResetIds').onclick = () => {
      if (!confirm('‚ö†Ô∏è Reset saved Discord message IDs?\n\nThis will clear stored header/table message IDs. The next post will create new messages instead of editing existing ones.')) {
        out('‚ùå Reset cancelled', 'err');
        return;
      }
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }
      setBusy(true, 'Resetting saved IDs‚Ä¶');
      out('‚ñ∂ Reset Saved IDs‚Ä¶');
      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) out('‚úÖ IDs reset', 'ok');
        else out('‚ùå ' + (res && res.error), 'err');
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_resetMsgIdsForCurrent(secret);
    };

    // Week-specific ID management
    let weeksData = []; // Store loaded weeks data

    $('btnLoadWeeks').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }

      setBusy(true, 'Loading weeks‚Ä¶');
      out('‚ñ∂ Loading weeks with stored message IDs‚Ä¶');

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok && res.data && res.data.weeks) {
          weeksData = res.data.weeks;
          const select = $('weekSelect');
          select.innerHTML = '<option value="">-- Select a week --</option>';

          if (weeksData.length === 0) {
            select.innerHTML = '<option value="">-- No weeks with stored IDs --</option>';
            out('‚ÑπÔ∏è No weeks found with stored message IDs', 'ok');
          } else {
            weeksData.forEach(w => {
              const option = document.createElement('option');
              option.value = w.weekKey;
              option.textContent = w.weekKey;
              select.appendChild(option);
            });
            out(`‚úÖ Loaded ${weeksData.length} week(s) with stored IDs`, 'ok');
          }

          $('weekIdInfo').textContent = 'Select a week to see stored IDs';
          $('btnClearWeekIds').disabled = true;
        } else {
          out('‚ùå ' + (res && res.error), 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_listWeeksWithMessageIds(secret);
    };

    $('weekSelect').onchange = () => {
      const weekKey = $('weekSelect').value;
      if (!weekKey) {
        $('weekIdInfo').textContent = 'Select a week to see stored IDs';
        $('btnClearWeekIds').disabled = true;
        return;
      }

      const week = weeksData.find(w => w.weekKey === weekKey);
      if (week && week.ids) {
        const lines = [];
        if (week.ids.header) lines.push(`Header: ${week.ids.header}`);
        if (week.ids.table) lines.push(`Table: ${week.ids.table}`);
        if (week.ids.rematch) lines.push(`Rematch: ${week.ids.rematch}`);

        $('weekIdInfo').innerHTML = lines.length > 0 ? lines.join('<br>') : 'No IDs found';
        $('btnClearWeekIds').disabled = false;
      } else {
        $('weekIdInfo').textContent = 'No IDs found for this week';
        $('btnClearWeekIds').disabled = true;
      }
    };

    $('btnClearWeekIds').onclick = () => {
      const weekKey = $('weekSelect').value;
      if (!weekKey) { out('‚ùå No week selected','err'); return; }

      if (!confirm(`‚ö†Ô∏è Clear stored message IDs for week "${weekKey}"?\n\nThis will force new Discord messages to be created next time this week is updated.`)) {
        out('‚ùå Clear cancelled', 'err');
        return;
      }

      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }

      setBusy(true, `Clearing IDs for ${weekKey}‚Ä¶`);
      out(`‚ñ∂ Clearing message IDs for week ${weekKey}‚Ä¶`);

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) {
          out(`‚úÖ Cleared IDs for ${weekKey}`, 'ok');
          // Reload the week list
          $('btnLoadWeeks').click();
        } else {
          out('‚ùå ' + (res && res.error), 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_resetMsgIdsForWeek(secret, weekKey);
    };

    // Debug dock controls
    $('dbgToggle').onclick = () => {
      $('debugDock').classList.toggle('collapsed');
      $('dbgToggle').textContent = $('debugDock').classList.contains('collapsed') ? 'Show' : 'Hide';
    };
    $('dbgCopy').onclick = async () => {
      try {
        await navigator.clipboard.writeText($('debugOut').textContent);
      } catch (e) {}
    };
    $('dbgClear').onclick = () => { $('debugOut').textContent = ''; };

    // ========== Automatic Polling Management ==========

    // Load polling status on page load and update UI
    function loadPollingStatus() {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) {
        $('pollingStatus').textContent = 'Enter secret first';
        $('pollingStatus').style.color = 'var(--muted)';
        return;
      }

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok && res.data) {
          const enabled = res.data.enabled;
          const count = res.data.count || 0;

          if (enabled) {
            $('pollingStatus').textContent = `üü¢ Enabled (${count} trigger${count !== 1 ? 's' : ''})`;
            $('pollingStatus').style.color = 'var(--ok)';
            $('pollingStatus').style.borderColor = 'var(--ok)';
          } else {
            $('pollingStatus').textContent = '‚ö™ Disabled';
            $('pollingStatus').style.color = 'var(--muted)';
            $('pollingStatus').style.borderColor = '#374151';
          }
        } else {
          $('pollingStatus').textContent = '‚ùå Error';
          $('pollingStatus').style.color = 'var(--err)';
        }
      }).withFailureHandler(e => {
        $('pollingStatus').textContent = '‚ùå Error: ' + e.message;
        $('pollingStatus').style.color = 'var(--err)';
      }).server_getPollingStatus(secret);
    }

    // Refresh status button
    $('btnRefreshStatus').onclick = () => {
      out('‚ñ∂ Refreshing polling status...');
      loadPollingStatus();
    };

    // Enable automatic polling
    $('btnEnablePolling').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }

      const interval = parseInt($('pollingInterval').value) || 5;
      if (interval < 1 || interval > 60) {
        out('‚ùå Interval must be between 1 and 60 minutes', 'err');
        return;
      }

      if (!confirm(`‚úÖ Enable automatic polling?\n\n‚Ä¢ Interval: Every ${interval} minute${interval !== 1 ? 's' : ''}\n‚Ä¢ Behavior: Polls from last pointer, allows re-scheduling\n\nThis will create a time-based trigger that runs automatically.`)) {
        out('‚ùå Enable cancelled', 'err');
        return;
      }

      setBusy(true, 'Enabling polling...');
      out(`‚ñ∂ Enabling automatic polling (${interval} minute interval)...`);

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) {
          out(`‚úÖ Automatic polling enabled:\n  Trigger ID: ${res.data.triggerId}\n  Interval: ${res.data.interval} minutes`, 'ok');
          loadPollingStatus(); // Refresh status
        } else {
          out('‚ùå ' + (res && res.error), 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_enablePolling(secret, interval);
    };

    // Disable automatic polling
    $('btnDisablePolling').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }

      if (!confirm('‚õî Disable automatic polling?\n\nThis will remove all automatic polling triggers. You can re-enable it anytime.')) {
        out('‚ùå Disable cancelled', 'err');
        return;
      }

      setBusy(true, 'Disabling polling...');
      out('‚ñ∂ Disabling automatic polling...');

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) {
          out(`‚úÖ Automatic polling disabled:\n  Triggers removed: ${res.data.removed}`, 'ok');
          loadPollingStatus(); // Refresh status
        } else {
          out('‚ùå ' + (res && res.error), 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_disablePolling(secret);
    };

    // Clear all scheduled matches
    $('btnClearScheduled').onclick = () => {
      const secret = sanitizeSecretFieldValue($('secret').value);
      if (!secret) { out('‚ùå Missing secret','err'); return; }

      if (!confirm('üóëÔ∏è Clear all scheduled matches from the store?\n\nThis will:\n‚Ä¢ Remove all stored schedule data from ALL weeks\n‚Ä¢ Keep other data (shoutcasters, etc.) intact\n‚Ä¢ Allow re-scheduling of all matches\n\nUseful before enabling automatic polling to ensure all matches get fresh schedules.')) {
        out('‚ùå Clear cancelled', 'err');
        return;
      }

      setBusy(true, 'Clearing schedules...');
      out('‚ñ∂ Clearing all scheduled matches...');

      google.script.run.withSuccessHandler(res => {
        if (res && res.ok) {
          out(`‚úÖ Cleared schedules from ${res.data.cleared} week store(s)`, 'ok');
        } else {
          out('‚ùå ' + (res && res.error), 'err');
        }
        setBusy(false);
      }).withFailureHandler(e => { out('‚ùå Script error: ' + e.message, 'err'); setBusy(false); })
      .server_clearAllScheduled(secret);
    };

    // Load polling status when secret is entered
    $('secret').addEventListener('blur', loadPollingStatus);

    // Load polling status on page load (after a short delay to let secret load from localStorage)
    setTimeout(loadPollingStatus, 500);


  </script>
</body>
</html>